var cl = {
    url: null,
    ssn: SnackBar,
    userAuth: null,
    userAuthToken: null,
    location: {
        data: {
            latitude: null,
            longitude: null,
            altitude: null,
            accuracy: null,
            altitudeAccuracy: null,
            heading: null,
            speed: null,
            timestamp: null,
        },
        locationSuccess: (position) => {
            cl.location.data.longitude = position.coords.longitude;
            cl.location.data.latitude = position.coords.latitude;
            cl.location.data.altitude = position.coords.altitude;
            cl.location.data.accuracy = position.coords.accuracy;
            cl.location.data.altitudeAccuracy = position.coords.altitudeAccuracy;
            cl.location.data.heading = position.coords.height;
            cl.location.data.speed = position.coords.speed;
            cl.location.data.timestamp = position.timestamp;
            // console.log('position', cl.location.data)
        },
        locationError: (error) => {
            const code = error.code;
            const message = error.message;
            navigator.permissions
                .query({
                    name: "geolocation"
                })
                .then(console.log(...data));
            console.log(code, message);
        },
        get: () => {
            navigator.geolocation.getCurrentPosition(
                cl.location.locationSuccess,
                cl.location.locationError
            );
        },
    },
    init: (url) => {
        cl.url = url;
        cl.location.get();
        cl.clientFingerprint();
        // cl.changeEvent()
        cl.applyMask()
    },
    clientFingerprint: () => {
        // Create a new ClientJS object
        const client = new ClientJS();
        const fingerprint = client.getCustomFingerprint();
        const x = document.getElementsByName("deviceFingerprint");
        var i;
        for (i = 0; i < x.length; i++) {
            if (x[i].type == "hidden") {
                x[i].value = fingerprint;
            }
        }
    },
    dd: (id) => {
        return document.querySelectorAll(id)
    },
    $: (id) => {
        return document.getElementById(id)
    },
    fornAuth: () => {
        var accLogin = cl.dd('.accLogin')
        accLogin.forEach(function (item, index) {
            item.addEventListener('click', function (event) {
                var accFormLogin = cl.dd('.accFormLogin')
                accFormLogin.forEach(function (e, i) {
                    // e.style.display = 'none'
                    e.classList.add("d-none");
                })
                event.preventDefault()
                const form = item.getAttribute("data-form")
                const elform = cl.$(form)
                if (elform !== null) {
                    //cl.$(form).style.display = 'inline'
                    cl.$(form).classList.remove("d-none");
                }
            })
        })
    },
    validateRetryPassword: () => {
        var formRecovery = cl.$('form-recovery')
        if (formRecovery !== null) {
            formRecovery.addEventListener('submit', function (event) {
                event.preventDefault()
                const pass1 = cl.$('acc_pass').value
                const pass2 = cl.$('retry_acc_pass').value
                if (pass1 !== pass2) {
                    cl.sn('As senhas não são iguais! repita a operação', 'warning')
                } else if (pass1.length < 8) {
                    cl.sn('Senha muito curta, tente com uma senha maior', 'warning')
                } else {
                    formRecovery.submit()
                }
            }, true)
        }
    },
    applyMask: () => {
        const arr = document.querySelectorAll("input[data-mask]");
        for (var i = 0; i < arr.length; i++) {
            var maskOptions = {
                mask: arr[i].getAttribute('data-mask')
            };
            var mask = IMask(arr[i], maskOptions)
        }
    },
    sn: function (msg, style) {
        cl.ssn({
            message: msg,
            status: style,
            timeout: 5000,
            width: "80vw",
            speed: 500,
            fixed: true,
            position: "tc"
        })
    },
    storage: {
        load: (name) => {
            const rawValue = localStorage.getItem(name);
            if (cl.storage.isJson(rawValue)) {
                return JSON.parse(rawValue);
            } else {
                return {
                    rawValue,
                };
            }
        },
        save: (name, obj) => {
            localStorage.setItem(name, JSON.stringify(obj));
        },
        delete: (name) => {
            localStorage.removeItem(name);
        },
        isJson: function (str) {
            try {
                JSON.parse(str);
            } catch (e) {
                return false;
            }
            return true;
        },
    },
    changeEvent: () => {
        console.log("hello check");

        const StoreEventId = cl.storage.load("eventDefault");

        if (StoreEventId != null) {
            const event = cl.dd(".headerEvent");
            event.forEach(function (item, index) {
                const eventId = item.value;

                if (
                    eventId != "" &&
                    eventId != "null" &&
                    eventId != null &&
                    eventId != StoreEventId
                ) {
                    console.log(`vou mudar de ${StoreEventId} para ${eventId}`);
                    cl.storage.save("eventDefault", eventId);
                    fetch(`${cl.url}/session/event/${eventId}`).then();
                }
            });
        }
    },
    empty: (value) => {
        // null ou undefined
        if (value === null || value === undefined) {
            return true;
        }

        // boolean: retorna true se for false
        if (typeof value === "boolean") {
            return value === false;
        }

        // number: retorna true se for 0
        if (typeof value === "number") {
            return value === 0;
        }

        // string: retorna true se for vazia ou "0"
        if (typeof value === "string") {
            return value.trim() === "" || value === "0";
        }

        // array: retorna true se não tiver itens
        if (Array.isArray(value)) {
            return value.length === 0;
        }

        // object: retorna true se não tiver propriedades
        if (typeof value === "object") {
            return Object.keys(value).length === 0;
        }

        // Se nada disso se aplicar, consideramos "não vazio"
        return false;
    },
    fields: (type = 'STRING', id, name, placeholder, value, mask, label, values) => {
        const field = {
            id, name, placeholder, value, mask, label, values
        }
        switch (type) {
            case 'STRING':
            case 'INTEGER':
            case 'FLOAT':

            case 'DATETIME':
            case 'DATE':
            case 'TIME':
                return cl.getInputField(field, type)

            case 'COMBOBOX':
                return cl.getComboField(field, type)

            case 'CHECKBOX':
                return cl.getCheckField(field, type)

            default:
                break;
        }
    },
    getInputField: (field, type) => {
        let formType = 'text'
        let step = ''

        if (type == 'INTEGER') {
            formType = 'number'
            step = "step=\"1\""
        }

        if (type == 'FLOAT') {
            formType = 'number'
            step = "step=\"0.01\""
        }

        if (type == 'DATE') {
            formType = 'date'
        }
        if (type == 'TIME') {
            formType = 'time'
        }
        if (type == 'DATETIME') {
            formType = 'datetime-local'
        }

        const require = field.required == 1 ? "require" : ''
        const classGuest = field.guest_enable == 1 ? 'bg-danger-soft' : ''
        return cl.addToDivFloat(`
                <input type="${formType}" step
                class="form-control field ${classGuest}" 
                id="field-${field.id}"
                name="field-${field.name}"
                placeholder="${field.placeholder}"
                value="${field.value}"
                data-mask="${field.mask}" 
                ${require} />
                <label for="field-${field.id}" class="form-label">${field.label}</label>
        `)
    },
    getComboField: (field, type) => {
        const items = field.values.split(",");
        const require = field.required == 1 ? "require" : ''
        const classGuest = field.guest_enable == 1 ? 'bg-danger-soft' : ''

        let options = '';
        items.forEach(el => {
            const selected = field.value == el ? 'selected="selected"' : ''
            options += `<option value="${el}" ${selected}>${el}</option>`
        })

        const content = `<select
                    class="form-select form-select-sm filters field ${classGuest}"
                    id="field-${field.id}"
                    name="field-${field.name}">
                        ${options}
                    </select>
                    <label for="field-${field.id}" class="form-label">${field.label}</label>`
        return cl.addToDivFloat(content);
    },
    getCheckField: (field, type) => {
        const checked = !cl.empty(field.value) ? "checked=\"\"" : ''
        const classGuest = field.guest_enable == 1 ? 'bg-danger-soft' : ''
        const content = `<label class="d-flex align-items-center mb-1">
                            <input class="d-none-cloaked field ${classGuest}"
                                type="checkbox"
                                id="field-${field.id}"
                                name="${field.name}"
                                value="1"
                                ${checked}
                            >
                            <i class="switch-icon switch-icon-primary switch-icon-xs"></i>
                            <span class="px-3 user-select-none">${field.label}</span>
                        </label>`

        return cl.addToDivFloat(content);
    },
    addToDivFloat: (content) => {
        return `<div class="col-lg-6"><div class="form-floating">${content}</div></div>`
    },
    validaToken: (key, urlLogin) => {
        cl.userAuth = null
        const userAuth = cl.storage.load(key)
        if (
            !cl.empty(userAuth)
            && !cl.empty(userAuth.access_token)
        ) {
            cl.userAuth = userAuth.user;
            cl.userAuthToken = userAuth.access_token;
            return true
        }
        window.location.href = urlLogin
    },
    getDeliveryEvent: () => {
        const event = cl.storage.load('app.delivery.event')
        if (
            !cl.empty(event)
        ) {
            return event
        }

        return false
    },
    getAccessTerminal: () => {
        const terminal = cl.storage.load('app.access.terminal')
        if (
            !cl.empty(terminal)
        ) {
            return terminal
        }

        return false
    }
};